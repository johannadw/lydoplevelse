{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces.js';\nimport { OptionsReader } from './OptionsReader.js';\nimport { distance, inAngleRanges } from './utils/math.js';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets.js';\nimport { eventShouldEndDrag, eventShouldStartDrag, isTouchEvent } from './utils/predicates.js';\nimport { supportsPassive } from './utils/supportsPassive.js';\nconst eventNames = {\n  [ListenerType.mouse]: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup',\n    contextmenu: 'contextmenu'\n  },\n  [ListenerType.touch]: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend'\n  },\n  [ListenerType.keyboard]: {\n    keydown: 'keydown'\n  }\n};\nexport class TouchBackendImpl {\n  /**\n  * Generate profiling statistics for the HTML5Backend.\n  */\n  profile() {\n    var ref;\n    return {\n      sourceNodes: this.sourceNodes.size,\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      targetNodes: this.targetNodes.size,\n      dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0\n    };\n  } // public for test\n\n\n  get document() {\n    return this.options.document;\n  }\n\n  setup() {\n    const root = this.options.rootElement;\n\n    if (!root) {\n      return;\n    }\n\n    invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n    TouchBackendImpl.isSetUp = true;\n    this.addEventListener(root, 'start', this.getTopMoveStartHandler());\n    this.addEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n    this.addEventListener(root, 'move', this.handleTopMove);\n    this.addEventListener(root, 'move', this.handleTopMoveCapture, true);\n    this.addEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n\n    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n      this.addEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.addEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n    }\n  }\n\n  teardown() {\n    const root = this.options.rootElement;\n\n    if (!root) {\n      return;\n    }\n\n    TouchBackendImpl.isSetUp = false;\n    this._mouseClientOffset = {};\n    this.removeEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n    this.removeEventListener(root, 'start', this.handleTopMoveStart);\n    this.removeEventListener(root, 'move', this.handleTopMoveCapture, true);\n    this.removeEventListener(root, 'move', this.handleTopMove);\n    this.removeEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n\n    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n      this.removeEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.removeEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n    }\n\n    this.uninstallSourceNodeRemovalObserver();\n  }\n\n  addEventListener(subject, event, handler) {\n    let capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const options = supportsPassive ? {\n      capture,\n      passive: false\n    } : capture;\n    this.listenerTypes.forEach(function (listenerType) {\n      const evt = eventNames[listenerType][event];\n\n      if (evt) {\n        subject.addEventListener(evt, handler, options);\n      }\n    });\n  }\n\n  removeEventListener(subject, event, handler) {\n    let capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const options = supportsPassive ? {\n      capture,\n      passive: false\n    } : capture;\n    this.listenerTypes.forEach(function (listenerType) {\n      const evt = eventNames[listenerType][event];\n\n      if (evt) {\n        subject.removeEventListener(evt, handler, options);\n      }\n    });\n  }\n\n  connectDragSource(sourceId, node) {\n    const handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n    this.sourceNodes.set(sourceId, node);\n    this.addEventListener(node, 'start', handleMoveStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      this.removeEventListener(node, 'start', handleMoveStart);\n    };\n  }\n\n  connectDragPreview(sourceId, node, options) {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n\n  connectDropTarget(targetId, node) {\n    const root = this.options.rootElement;\n\n    if (!this.document || !root) {\n      return () => {\n        /* noop */\n      };\n    }\n\n    const handleMove = e => {\n      if (!this.document || !root || !this.monitor.isDragging()) {\n        return;\n      }\n\n      let coords;\n      /**\n      * Grab the coordinates for the current mouse/touch position\n      */\n\n      switch (e.type) {\n        case eventNames.mouse.move:\n          coords = {\n            x: e.clientX,\n            y: e.clientY\n          };\n          break;\n\n        case eventNames.touch.move:\n          var ref, ref1;\n          coords = {\n            x: ((ref = e.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,\n            y: ((ref1 = e.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0\n          };\n          break;\n      }\n      /**\n      * Use the coordinates to grab the element the drag ended on.\n      * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n      */\n\n\n      const droppedOn = coords != null ? this.document.elementFromPoint(coords.x, coords.y) : undefined;\n      const childMatch = droppedOn && node.contains(droppedOn);\n\n      if (droppedOn === node || childMatch) {\n        return this.handleMove(e, targetId);\n      }\n    };\n    /**\n    * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n    */\n\n\n    this.addEventListener(this.document.body, 'move', handleMove);\n    this.targetNodes.set(targetId, node);\n    return () => {\n      if (this.document) {\n        this.targetNodes.delete(targetId);\n        this.removeEventListener(this.document.body, 'move', handleMove);\n      }\n    };\n  }\n\n  getTopMoveStartHandler() {\n    if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n      return this.handleTopMoveStart;\n    }\n\n    return this.handleTopMoveStartDelay;\n  }\n\n  installSourceNodeRemovalObserver(node) {\n    this.uninstallSourceNodeRemovalObserver();\n    this.draggedSourceNode = node;\n    this.draggedSourceNodeRemovalObserver = new MutationObserver(() => {\n      if (node && !node.parentElement) {\n        this.resurrectSourceNode();\n        this.uninstallSourceNodeRemovalObserver();\n      }\n    });\n\n    if (!node || !node.parentElement) {\n      return;\n    }\n\n    this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n      childList: true\n    });\n  }\n\n  resurrectSourceNode() {\n    if (this.document && this.draggedSourceNode) {\n      this.draggedSourceNode.style.display = 'none';\n      this.draggedSourceNode.removeAttribute('data-reactid');\n      this.document.body.appendChild(this.draggedSourceNode);\n    }\n  }\n\n  uninstallSourceNodeRemovalObserver() {\n    if (this.draggedSourceNodeRemovalObserver) {\n      this.draggedSourceNodeRemovalObserver.disconnect();\n    }\n\n    this.draggedSourceNodeRemovalObserver = undefined;\n    this.draggedSourceNode = undefined;\n  }\n\n  constructor(manager, context, options) {\n    this.getSourceClientOffset = sourceId => {\n      const element = this.sourceNodes.get(sourceId);\n      return element && getNodeClientOffset(element);\n    };\n\n    this.handleTopMoveStartCapture = e => {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      this.moveStartSourceIds = [];\n    };\n\n    this.handleMoveStart = sourceId => {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(this.moveStartSourceIds)) {\n        this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n\n    this.handleTopMoveStart = e => {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      } // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\n      const clientOffset = getEventClientOffset(e);\n\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n\n        this._mouseClientOffset = clientOffset;\n      }\n\n      this.waitingForDelay = false;\n    };\n\n    this.handleTopMoveStartDelay = e => {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      const delay = e.type === eventNames.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;\n      this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);\n      this.waitingForDelay = true;\n    };\n\n    this.handleTopMoveCapture = () => {\n      this.dragOverTargetIds = [];\n    };\n\n    this.handleMove = (_evt, targetId) => {\n      if (this.dragOverTargetIds) {\n        this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n\n    this.handleTopMove = e1 => {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n      }\n\n      if (!this.document || this.waitingForDelay) {\n        return;\n      }\n\n      const {\n        moveStartSourceIds,\n        dragOverTargetIds\n      } = this;\n      const enableHoverOutsideTarget = this.options.enableHoverOutsideTarget;\n      const clientOffset = getEventClientOffset(e1, this.lastTargetTouchFallback);\n\n      if (!clientOffset) {\n        return;\n      } // If the touch move started as a scroll, or is is between the scroll angles\n\n\n      if (this._isScrolling || !this.monitor.isDragging() && inAngleRanges(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, this.options.scrollAngleRanges)) {\n        this._isScrolling = true;\n        return;\n      } // If we're not dragging and we've moved a little, that counts as a drag start\n\n\n      if (!this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n      this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (this.options.touchSlop ? this.options.touchSlop : 0)) {\n        this.moveStartSourceIds = undefined;\n        this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: this._mouseClientOffset,\n          getSourceClientOffset: this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n\n      if (!this.monitor.isDragging()) {\n        return;\n      }\n\n      const sourceNode = this.sourceNodes.get(this.monitor.getSourceId());\n      this.installSourceNodeRemovalObserver(sourceNode);\n      this.actions.publishDragSource();\n      if (e1.cancelable) e1.preventDefault(); // Get the node elements of the hovered DropTargets\n\n      const dragOverTargetNodes = (dragOverTargetIds || []).map(key => this.targetNodes.get(key)).filter(e => !!e); // Get the a ordered list of nodes that are touched by\n\n      const elementsAtPoint = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : this.document.elementsFromPoint(clientOffset.x, clientOffset.y); // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\n      const elementsAtPointExtended = [];\n\n      for (const nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n\n        let currentNode = elementsAtPoint[nodeId];\n\n        if (currentNode != null) {\n          elementsAtPointExtended.push(currentNode);\n        }\n\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n\n      const orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(node => dragOverTargetNodes.indexOf(node) > -1) // Map back the nodes elements to targetIds\n      .map(node => this._getDropTargetId(node)) // Filter off possible null rows\n      .filter(node => !!node).filter((id, index, ids) => ids.indexOf(id) === index); // Invoke hover for drop targets when source node is still over and pointer is outside\n\n      if (enableHoverOutsideTarget) {\n        for (const targetId in this.targetNodes) {\n          const targetNode = this.targetNodes.get(targetId);\n\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      } // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\n\n      orderedDragOverTargetIds.reverse();\n      this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n    *\n    * visible for testing\n    */\n\n\n    this._getDropTargetId = node => {\n      const keys = this.targetNodes.keys();\n      let next = keys.next();\n\n      while (next.done === false) {\n        const targetId = next.value;\n\n        if (node === this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n\n      return undefined;\n    };\n\n    this.handleTopMoveEndCapture = e => {\n      this._isScrolling = false;\n      this.lastTargetTouchFallback = undefined;\n\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n\n      if (!this.monitor.isDragging() || this.monitor.didDrop()) {\n        this.moveStartSourceIds = undefined;\n        return;\n      }\n\n      if (e.cancelable) e.preventDefault();\n      this._mouseClientOffset = {};\n      this.uninstallSourceNodeRemovalObserver();\n      this.actions.drop();\n      this.actions.endDrag();\n    };\n\n    this.handleCancelOnEscape = e => {\n      if (e.key === 'Escape' && this.monitor.isDragging()) {\n        this._mouseClientOffset = {};\n        this.uninstallSourceNodeRemovalObserver();\n        this.actions.endDrag();\n      }\n    };\n\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["invariant","ListenerType","OptionsReader","distance","inAngleRanges","getEventClientOffset","getNodeClientOffset","eventShouldEndDrag","eventShouldStartDrag","isTouchEvent","supportsPassive","eventNames","mouse","start","move","end","contextmenu","touch","keyboard","keydown","TouchBackendImpl","profile","ref","sourceNodes","size","sourcePreviewNodes","sourcePreviewNodeOptions","targetNodes","dragOverTargetIds","length","document","options","setup","root","rootElement","isSetUp","addEventListener","getTopMoveStartHandler","handleTopMoveStartCapture","handleTopMove","handleTopMoveCapture","handleTopMoveEndCapture","enableMouseEvents","ignoreContextMenu","enableKeyboardEvents","handleCancelOnEscape","teardown","_mouseClientOffset","removeEventListener","handleTopMoveStart","uninstallSourceNodeRemovalObserver","subject","event","handler","capture","passive","listenerTypes","forEach","listenerType","evt","connectDragSource","sourceId","node","handleMoveStart","bind","set","delete","connectDragPreview","connectDropTarget","targetId","handleMove","e","monitor","isDragging","coords","type","x","clientX","y","clientY","ref1","touches","droppedOn","elementFromPoint","undefined","childMatch","contains","body","delayTouchStart","delayMouseStart","handleTopMoveStartDelay","installSourceNodeRemovalObserver","draggedSourceNode","draggedSourceNodeRemovalObserver","MutationObserver","parentElement","resurrectSourceNode","observe","childList","style","display","removeAttribute","appendChild","disconnect","constructor","manager","context","getSourceClientOffset","element","get","moveStartSourceIds","Array","isArray","unshift","clientOffset","lastTargetTouchFallback","targetTouches","waitingForDelay","delay","timeout","setTimeout","_evt","clearTimeout","enableHoverOutsideTarget","_isScrolling","scrollAngleRanges","hasOwnProperty","touchSlop","actions","beginDrag","publishSource","sourceNode","getSourceId","publishDragSource","cancelable","preventDefault","dragOverTargetNodes","map","key","filter","elementsAtPoint","getDropTargetElementsAtPoint","elementsFromPoint","elementsAtPointExtended","nodeId","currentNode","push","indexOf","orderedDragOverTargetIds","_getDropTargetId","id","index","ids","targetNode","reverse","hover","keys","next","done","value","didDrop","drop","endDrag","getActions","getMonitor","Map","enableTouchEvents"],"sources":["/Users/johannadeweerdt/Documents/school/erasmus/code/lydoplevelse-test/node_modules/react-dnd-touch-backend/src/TouchBackendImpl.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type {\n\tBackend,\n\tDragDropActions,\n\tDragDropManager,\n\tDragDropMonitor,\n\tIdentifier,\n\tUnsubscribe,\n\tXYCoord,\n} from 'dnd-core'\n\nimport type {\n\tEventName,\n\tTouchBackendContext,\n\tTouchBackendOptions,\n} from './interfaces.js'\nimport { ListenerType } from './interfaces.js'\nimport { OptionsReader } from './OptionsReader.js'\nimport { distance, inAngleRanges } from './utils/math.js'\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets.js'\nimport {\n\teventShouldEndDrag,\n\teventShouldStartDrag,\n\tisTouchEvent,\n} from './utils/predicates.js'\nimport { supportsPassive } from './utils/supportsPassive.js'\n\nconst eventNames: Record<ListenerType, EventName> = {\n\t[ListenerType.mouse]: {\n\t\tstart: 'mousedown',\n\t\tmove: 'mousemove',\n\t\tend: 'mouseup',\n\t\tcontextmenu: 'contextmenu',\n\t},\n\t[ListenerType.touch]: {\n\t\tstart: 'touchstart',\n\t\tmove: 'touchmove',\n\t\tend: 'touchend',\n\t},\n\t[ListenerType.keyboard]: {\n\t\tkeydown: 'keydown',\n\t},\n}\n\nexport class TouchBackendImpl implements Backend {\n\tprivate options: OptionsReader\n\n\t// React-DnD Dependencies\n\tprivate actions: DragDropActions\n\tprivate monitor: DragDropMonitor\n\n\t// Internal State\n\tprivate static isSetUp: boolean\n\tpublic sourceNodes: Map<Identifier, HTMLElement>\n\tpublic sourcePreviewNodes: Map<string, HTMLElement>\n\tpublic sourcePreviewNodeOptions: Map<string, any>\n\tpublic targetNodes: Map<string, HTMLElement>\n\tprivate _mouseClientOffset: Partial<XYCoord>\n\tprivate _isScrolling: boolean\n\tprivate listenerTypes: ListenerType[]\n\tprivate moveStartSourceIds: string[] | undefined\n\tprivate waitingForDelay: boolean | undefined\n\tprivate timeout: ReturnType<typeof setTimeout> | undefined\n\tprivate dragOverTargetIds: string[] | undefined\n\tprivate draggedSourceNode: HTMLElement | undefined\n\tprivate draggedSourceNodeRemovalObserver: MutationObserver | undefined\n\n\t// Patch for iOS 13, discussion over #1585\n\tprivate lastTargetTouchFallback: Touch | undefined\n\n\tpublic constructor(\n\t\tmanager: DragDropManager,\n\t\tcontext: TouchBackendContext,\n\t\toptions: Partial<TouchBackendOptions>,\n\t) {\n\t\tthis.options = new OptionsReader(options, context)\n\t\tthis.actions = manager.getActions()\n\t\tthis.monitor = manager.getMonitor()\n\n\t\tthis.sourceNodes = new Map()\n\t\tthis.sourcePreviewNodes = new Map()\n\t\tthis.sourcePreviewNodeOptions = new Map()\n\t\tthis.targetNodes = new Map()\n\t\tthis.listenerTypes = []\n\t\tthis._mouseClientOffset = {}\n\t\tthis._isScrolling = false\n\n\t\tif (this.options.enableMouseEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.mouse)\n\t\t}\n\n\t\tif (this.options.enableTouchEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.touch)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.keyboard)\n\t\t}\n\t}\n\n\t/**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */\n\tpublic profile(): Record<string, number> {\n\t\treturn {\n\t\t\tsourceNodes: this.sourceNodes.size,\n\t\t\tsourcePreviewNodes: this.sourcePreviewNodes.size,\n\t\t\tsourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n\t\t\ttargetNodes: this.targetNodes.size,\n\t\t\tdragOverTargetIds: this.dragOverTargetIds?.length || 0,\n\t\t}\n\t}\n\n\t// public for test\n\tpublic get document(): Document | undefined {\n\t\treturn this.options.document\n\t}\n\n\tpublic setup(): void {\n\t\tconst root = this.options.rootElement\n\t\tif (!root) {\n\t\t\treturn\n\t\t}\n\n\t\tinvariant(\n\t\t\t!TouchBackendImpl.isSetUp,\n\t\t\t'Cannot have two Touch backends at the same time.',\n\t\t)\n\t\tTouchBackendImpl.isSetUp = true\n\n\t\tthis.addEventListener(root, 'start', this.getTopMoveStartHandler() as any)\n\t\tthis.addEventListener(\n\t\t\troot,\n\t\t\t'start',\n\t\t\tthis.handleTopMoveStartCapture as any,\n\t\t\ttrue,\n\t\t)\n\t\tthis.addEventListener(root, 'move', this.handleTopMove as any)\n\t\tthis.addEventListener(root, 'move', this.handleTopMoveCapture, true)\n\t\tthis.addEventListener(\n\t\t\troot,\n\t\t\t'end',\n\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\ttrue,\n\t\t)\n\n\t\tif (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n\t\t\tthis.addEventListener(\n\t\t\t\troot,\n\t\t\t\t'contextmenu',\n\t\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\t)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.addEventListener(\n\t\t\t\troot,\n\t\t\t\t'keydown',\n\t\t\t\tthis.handleCancelOnEscape as any,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\t}\n\n\tpublic teardown(): void {\n\t\tconst root = this.options.rootElement\n\t\tif (!root) {\n\t\t\treturn\n\t\t}\n\n\t\tTouchBackendImpl.isSetUp = false\n\t\tthis._mouseClientOffset = {}\n\n\t\tthis.removeEventListener(\n\t\t\troot,\n\t\t\t'start',\n\t\t\tthis.handleTopMoveStartCapture as any,\n\t\t\ttrue,\n\t\t)\n\t\tthis.removeEventListener(root, 'start', this.handleTopMoveStart as any)\n\t\tthis.removeEventListener(root, 'move', this.handleTopMoveCapture, true)\n\t\tthis.removeEventListener(root, 'move', this.handleTopMove as any)\n\t\tthis.removeEventListener(\n\t\t\troot,\n\t\t\t'end',\n\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\ttrue,\n\t\t)\n\n\t\tif (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n\t\t\tthis.removeEventListener(\n\t\t\t\troot,\n\t\t\t\t'contextmenu',\n\t\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\t)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.removeEventListener(\n\t\t\t\troot,\n\t\t\t\t'keydown',\n\t\t\t\tthis.handleCancelOnEscape as any,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\t}\n\n\tprivate addEventListener<K extends keyof EventName>(\n\t\tsubject: Node,\n\t\tevent: K,\n\t\thandler: (e: any) => void,\n\t\tcapture = false,\n\t) {\n\t\tconst options = supportsPassive ? { capture, passive: false } : capture\n\n\t\tthis.listenerTypes.forEach(function (listenerType) {\n\t\t\tconst evt = eventNames[listenerType][event]\n\n\t\t\tif (evt) {\n\t\t\t\tsubject.addEventListener(evt as any, handler as any, options)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate removeEventListener<K extends keyof EventName>(\n\t\tsubject: Node,\n\t\tevent: K,\n\t\thandler: (e: any) => void,\n\t\tcapture = false,\n\t) {\n\t\tconst options = supportsPassive ? { capture, passive: false } : capture\n\n\t\tthis.listenerTypes.forEach(function (listenerType) {\n\t\t\tconst evt = eventNames[listenerType][event]\n\n\t\t\tif (evt) {\n\t\t\t\tsubject.removeEventListener(evt as any, handler as any, options)\n\t\t\t}\n\t\t})\n\t}\n\n\tpublic connectDragSource(sourceId: string, node: HTMLElement): Unsubscribe {\n\t\tconst handleMoveStart = this.handleMoveStart.bind(this, sourceId)\n\t\tthis.sourceNodes.set(sourceId, node)\n\n\t\tthis.addEventListener(node, 'start', handleMoveStart)\n\n\t\treturn (): void => {\n\t\t\tthis.sourceNodes.delete(sourceId)\n\t\t\tthis.removeEventListener(node, 'start', handleMoveStart)\n\t\t}\n\t}\n\n\tpublic connectDragPreview(\n\t\tsourceId: string,\n\t\tnode: HTMLElement,\n\t\toptions: unknown,\n\t): Unsubscribe {\n\t\tthis.sourcePreviewNodeOptions.set(sourceId, options)\n\t\tthis.sourcePreviewNodes.set(sourceId, node)\n\n\t\treturn (): void => {\n\t\t\tthis.sourcePreviewNodes.delete(sourceId)\n\t\t\tthis.sourcePreviewNodeOptions.delete(sourceId)\n\t\t}\n\t}\n\n\tpublic connectDropTarget(targetId: string, node: HTMLElement): Unsubscribe {\n\t\tconst root = this.options.rootElement\n\t\tif (!this.document || !root) {\n\t\t\treturn (): void => {\n\t\t\t\t/* noop */\n\t\t\t}\n\t\t}\n\n\t\tconst handleMove = (e: MouseEvent | TouchEvent) => {\n\t\t\tif (!this.document || !root || !this.monitor.isDragging()) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet coords\n\n\t\t\t/**\n\t\t\t * Grab the coordinates for the current mouse/touch position\n\t\t\t */\n\t\t\tswitch (e.type) {\n\t\t\t\tcase eventNames.mouse.move:\n\t\t\t\t\tcoords = {\n\t\t\t\t\t\tx: (e as MouseEvent).clientX,\n\t\t\t\t\t\ty: (e as MouseEvent).clientY,\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase eventNames.touch.move:\n\t\t\t\t\tcoords = {\n\t\t\t\t\t\tx: (e as TouchEvent).touches[0]?.clientX || 0,\n\t\t\t\t\t\ty: (e as TouchEvent).touches[0]?.clientY || 0,\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Use the coordinates to grab the element the drag ended on.\n\t\t\t * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n\t\t\t */\n\t\t\tconst droppedOn =\n\t\t\t\tcoords != null\n\t\t\t\t\t? this.document.elementFromPoint(coords.x, coords.y)\n\t\t\t\t\t: undefined\n\t\t\tconst childMatch = droppedOn && node.contains(droppedOn)\n\n\t\t\tif (droppedOn === node || childMatch) {\n\t\t\t\treturn this.handleMove(e, targetId)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n\t\t */\n\t\tthis.addEventListener(this.document.body, 'move', handleMove as any)\n\t\tthis.targetNodes.set(targetId, node)\n\n\t\treturn (): void => {\n\t\t\tif (this.document) {\n\t\t\t\tthis.targetNodes.delete(targetId)\n\t\t\t\tthis.removeEventListener(this.document.body, 'move', handleMove as any)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getSourceClientOffset = (sourceId: string): XYCoord | undefined => {\n\t\tconst element = this.sourceNodes.get(sourceId)\n\t\treturn element && getNodeClientOffset(element)\n\t}\n\n\tpublic handleTopMoveStartCapture = (e: Event): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.moveStartSourceIds = []\n\t}\n\n\tpublic handleMoveStart = (sourceId: string): void => {\n\t\t// Just because we received an event doesn't necessarily mean we need to collect drag sources.\n\t\t// We only collect start collecting drag sources on touch and left mouse events.\n\t\tif (Array.isArray(this.moveStartSourceIds)) {\n\t\t\tthis.moveStartSourceIds.unshift(sourceId)\n\t\t}\n\t}\n\n\tprivate getTopMoveStartHandler() {\n\t\tif (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n\t\t\treturn this.handleTopMoveStart\n\t\t}\n\n\t\treturn this.handleTopMoveStartDelay\n\t}\n\n\tpublic handleTopMoveStart = (e: MouseEvent | TouchEvent): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Don't prematurely preventDefault() here since it might:\n\t\t// 1. Mess up scrolling\n\t\t// 2. Mess up long tap (which brings up context menu)\n\t\t// 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\t\tconst clientOffset = getEventClientOffset(e)\n\t\tif (clientOffset) {\n\t\t\tif (isTouchEvent(e)) {\n\t\t\t\tthis.lastTargetTouchFallback = e.targetTouches[0]\n\t\t\t}\n\t\t\tthis._mouseClientOffset = clientOffset\n\t\t}\n\t\tthis.waitingForDelay = false\n\t}\n\n\tpublic handleTopMoveStartDelay = (e: Event): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tconst delay =\n\t\t\te.type === eventNames.touch.start\n\t\t\t\t? this.options.delayTouchStart\n\t\t\t\t: this.options.delayMouseStart\n\t\tthis.timeout = setTimeout(\n\t\t\tthis.handleTopMoveStart.bind(this, e as any),\n\t\t\tdelay,\n\t\t) as any as ReturnType<typeof setTimeout>\n\t\tthis.waitingForDelay = true\n\t}\n\n\tpublic handleTopMoveCapture = (): void => {\n\t\tthis.dragOverTargetIds = []\n\t}\n\n\tpublic handleMove = (\n\t\t_evt: MouseEvent | TouchEvent,\n\t\ttargetId: string,\n\t): void => {\n\t\tif (this.dragOverTargetIds) {\n\t\t\tthis.dragOverTargetIds.unshift(targetId)\n\t\t}\n\t}\n\n\tpublic handleTopMove = (e: TouchEvent | MouseEvent): void => {\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout)\n\t\t}\n\t\tif (!this.document || this.waitingForDelay) {\n\t\t\treturn\n\t\t}\n\t\tconst { moveStartSourceIds, dragOverTargetIds } = this\n\t\tconst enableHoverOutsideTarget = this.options.enableHoverOutsideTarget\n\n\t\tconst clientOffset = getEventClientOffset(e, this.lastTargetTouchFallback)\n\n\t\tif (!clientOffset) {\n\t\t\treturn\n\t\t}\n\n\t\t// If the touch move started as a scroll, or is is between the scroll angles\n\t\tif (\n\t\t\tthis._isScrolling ||\n\t\t\t(!this.monitor.isDragging() &&\n\t\t\t\tinAngleRanges(\n\t\t\t\t\tthis._mouseClientOffset.x || 0,\n\t\t\t\t\tthis._mouseClientOffset.y || 0,\n\t\t\t\t\tclientOffset.x,\n\t\t\t\t\tclientOffset.y,\n\t\t\t\t\tthis.options.scrollAngleRanges,\n\t\t\t\t))\n\t\t) {\n\t\t\tthis._isScrolling = true\n\t\t\treturn\n\t\t}\n\n\t\t// If we're not dragging and we've moved a little, that counts as a drag start\n\t\tif (\n\t\t\t!this.monitor.isDragging() &&\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tthis._mouseClientOffset.hasOwnProperty('x') &&\n\t\t\tmoveStartSourceIds &&\n\t\t\tdistance(\n\t\t\t\tthis._mouseClientOffset.x || 0,\n\t\t\t\tthis._mouseClientOffset.y || 0,\n\t\t\t\tclientOffset.x,\n\t\t\t\tclientOffset.y,\n\t\t\t) > (this.options.touchSlop ? this.options.touchSlop : 0)\n\t\t) {\n\t\t\tthis.moveStartSourceIds = undefined\n\n\t\t\tthis.actions.beginDrag(moveStartSourceIds, {\n\t\t\t\tclientOffset: this._mouseClientOffset,\n\t\t\t\tgetSourceClientOffset: this.getSourceClientOffset,\n\t\t\t\tpublishSource: false,\n\t\t\t})\n\t\t}\n\n\t\tif (!this.monitor.isDragging()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst sourceNode = this.sourceNodes.get(\n\t\t\tthis.monitor.getSourceId() as string,\n\t\t)\n\t\tthis.installSourceNodeRemovalObserver(sourceNode)\n\t\tthis.actions.publishDragSource()\n\n\t\tif (e.cancelable) e.preventDefault()\n\n\t\t// Get the node elements of the hovered DropTargets\n\t\tconst dragOverTargetNodes: HTMLElement[] = (dragOverTargetIds || [])\n\t\t\t.map((key) => this.targetNodes.get(key))\n\t\t\t.filter((e) => !!e) as HTMLElement[]\n\n\t\t// Get the a ordered list of nodes that are touched by\n\t\tconst elementsAtPoint = this.options.getDropTargetElementsAtPoint\n\t\t\t? this.options.getDropTargetElementsAtPoint(\n\t\t\t\t\tclientOffset.x,\n\t\t\t\t\tclientOffset.y,\n\t\t\t\t\tdragOverTargetNodes,\n\t\t\t  )\n\t\t\t: this.document.elementsFromPoint(clientOffset.x, clientOffset.y)\n\t\t// Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\t\tconst elementsAtPointExtended: Element[] = []\n\t\tfor (const nodeId in elementsAtPoint) {\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tif (!elementsAtPoint.hasOwnProperty(nodeId)) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlet currentNode: Element | undefined | null = elementsAtPoint[nodeId]\n\t\t\tif (currentNode != null) {\n\t\t\t\telementsAtPointExtended.push(currentNode)\n\t\t\t}\n\t\t\twhile (currentNode) {\n\t\t\t\tcurrentNode = currentNode.parentElement\n\t\t\t\tif (\n\t\t\t\t\tcurrentNode &&\n\t\t\t\t\telementsAtPointExtended.indexOf(currentNode) === -1\n\t\t\t\t) {\n\t\t\t\t\telementsAtPointExtended.push(currentNode)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst orderedDragOverTargetIds: string[] = elementsAtPointExtended\n\t\t\t// Filter off nodes that arent a hovered DropTargets nodes\n\t\t\t.filter((node) => dragOverTargetNodes.indexOf(node as HTMLElement) > -1)\n\t\t\t// Map back the nodes elements to targetIds\n\t\t\t.map((node) => this._getDropTargetId(node))\n\t\t\t// Filter off possible null rows\n\t\t\t.filter((node) => !!node)\n\t\t\t.filter((id, index, ids) => ids.indexOf(id) === index) as string[]\n\n\t\t// Invoke hover for drop targets when source node is still over and pointer is outside\n\t\tif (enableHoverOutsideTarget) {\n\t\t\tfor (const targetId in this.targetNodes) {\n\t\t\t\tconst targetNode = this.targetNodes.get(targetId)\n\t\t\t\tif (\n\t\t\t\t\tsourceNode &&\n\t\t\t\t\ttargetNode &&\n\t\t\t\t\ttargetNode.contains(sourceNode) &&\n\t\t\t\t\torderedDragOverTargetIds.indexOf(targetId) === -1\n\t\t\t\t) {\n\t\t\t\t\torderedDragOverTargetIds.unshift(targetId)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\t\torderedDragOverTargetIds.reverse()\n\n\t\tthis.actions.hover(orderedDragOverTargetIds, {\n\t\t\tclientOffset: clientOffset,\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * visible for testing\n\t */\n\tpublic _getDropTargetId = (node: Element): Identifier | undefined => {\n\t\tconst keys = this.targetNodes.keys()\n\t\tlet next = keys.next()\n\t\twhile (next.done === false) {\n\t\t\tconst targetId = next.value\n\t\t\tif (node === this.targetNodes.get(targetId)) {\n\t\t\t\treturn targetId\n\t\t\t} else {\n\t\t\t\tnext = keys.next()\n\t\t\t}\n\t\t}\n\t\treturn undefined\n\t}\n\n\tpublic handleTopMoveEndCapture = (e: Event): void => {\n\t\tthis._isScrolling = false\n\t\tthis.lastTargetTouchFallback = undefined\n\n\t\tif (!eventShouldEndDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (!this.monitor.isDragging() || this.monitor.didDrop()) {\n\t\t\tthis.moveStartSourceIds = undefined\n\t\t\treturn\n\t\t}\n\n\t\tif (e.cancelable) e.preventDefault()\n\n\t\tthis._mouseClientOffset = {}\n\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\tthis.actions.drop()\n\t\tthis.actions.endDrag()\n\t}\n\n\tpublic handleCancelOnEscape = (e: KeyboardEvent): void => {\n\t\tif (e.key === 'Escape' && this.monitor.isDragging()) {\n\t\t\tthis._mouseClientOffset = {}\n\n\t\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\t\tthis.actions.endDrag()\n\t\t}\n\t}\n\n\tprivate installSourceNodeRemovalObserver(node: HTMLElement | undefined) {\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\n\t\tthis.draggedSourceNode = node\n\t\tthis.draggedSourceNodeRemovalObserver = new MutationObserver(() => {\n\t\t\tif (node && !node.parentElement) {\n\t\t\t\tthis.resurrectSourceNode()\n\t\t\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\t\t}\n\t\t})\n\n\t\tif (!node || !node.parentElement) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n\t\t\tchildList: true,\n\t\t})\n\t}\n\n\tprivate resurrectSourceNode() {\n\t\tif (this.document && this.draggedSourceNode) {\n\t\t\tthis.draggedSourceNode.style.display = 'none'\n\t\t\tthis.draggedSourceNode.removeAttribute('data-reactid')\n\t\t\tthis.document.body.appendChild(this.draggedSourceNode)\n\t\t}\n\t}\n\n\tprivate uninstallSourceNodeRemovalObserver() {\n\t\tif (this.draggedSourceNodeRemovalObserver) {\n\t\t\tthis.draggedSourceNodeRemovalObserver.disconnect()\n\t\t}\n\n\t\tthis.draggedSourceNodeRemovalObserver = undefined\n\t\tthis.draggedSourceNode = undefined\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}