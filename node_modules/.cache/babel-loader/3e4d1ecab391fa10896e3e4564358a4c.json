{"ast":null,"code":"import _classCallCheck from \"/Users/johannadeweerdt/Documents/school/erasmus/code/lydoplevelse/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/johannadeweerdt/Documents/school/erasmus/code/lydoplevelse/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { invariant } from '@react-dnd/invariant';\nimport { getDifferenceFromInitialOffset as _getDifferenceFromInitialOffset, getSourceClientOffset as _getSourceClientOffset } from '../utils/coords.js';\nimport { areDirty } from '../utils/dirtiness.js';\nimport { matchesType } from '../utils/matchesType.js';\nexport var DragDropMonitorImpl = /*#__PURE__*/function () {\n  function DragDropMonitorImpl(store, registry) {\n    _classCallCheck(this, DragDropMonitorImpl);\n\n    this.store = store;\n    this.registry = registry;\n  }\n\n  _createClass(DragDropMonitorImpl, [{\n    key: \"subscribeToStateChange\",\n    value: function subscribeToStateChange(listener) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var handlerIds = options.handlerIds;\n      invariant(typeof listener === 'function', 'listener must be a function.');\n      invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n      var prevStateId = this.store.getState().stateId;\n\n      var handleChange = function handleChange() {\n        var state = _this.store.getState();\n\n        var currentStateId = state.stateId;\n\n        try {\n          var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n\n          if (!canSkipListener) {\n            listener();\n          }\n        } finally {\n          prevStateId = currentStateId;\n        }\n      };\n\n      return this.store.subscribe(handleChange);\n    }\n  }, {\n    key: \"subscribeToOffsetChange\",\n    value: function subscribeToOffsetChange(listener) {\n      var _this2 = this;\n\n      invariant(typeof listener === 'function', 'listener must be a function.');\n      var previousState = this.store.getState().dragOffset;\n\n      var handleChange = function handleChange() {\n        var nextState = _this2.store.getState().dragOffset;\n\n        if (nextState === previousState) {\n          return;\n        }\n\n        previousState = nextState;\n        listener();\n      };\n\n      return this.store.subscribe(handleChange);\n    }\n  }, {\n    key: \"canDragSource\",\n    value: function canDragSource(sourceId) {\n      if (!sourceId) {\n        return false;\n      }\n\n      var source = this.registry.getSource(sourceId);\n      invariant(source, \"Expected to find a valid source. sourceId=\".concat(sourceId));\n\n      if (this.isDragging()) {\n        return false;\n      }\n\n      return source.canDrag(this, sourceId);\n    }\n  }, {\n    key: \"canDropOnTarget\",\n    value: function canDropOnTarget(targetId) {\n      // undefined on initial render\n      if (!targetId) {\n        return false;\n      }\n\n      var target = this.registry.getTarget(targetId);\n      invariant(target, \"Expected to find a valid target. targetId=\".concat(targetId));\n\n      if (!this.isDragging() || this.didDrop()) {\n        return false;\n      }\n\n      var targetType = this.registry.getTargetType(targetId);\n      var draggedItemType = this.getItemType();\n      return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n  }, {\n    key: \"isDragging\",\n    value: function isDragging() {\n      return Boolean(this.getItemType());\n    }\n  }, {\n    key: \"isDraggingSource\",\n    value: function isDraggingSource(sourceId) {\n      // undefined on initial render\n      if (!sourceId) {\n        return false;\n      }\n\n      var source = this.registry.getSource(sourceId, true);\n      invariant(source, \"Expected to find a valid source. sourceId=\".concat(sourceId));\n\n      if (!this.isDragging() || !this.isSourcePublic()) {\n        return false;\n      }\n\n      var sourceType = this.registry.getSourceType(sourceId);\n      var draggedItemType = this.getItemType();\n\n      if (sourceType !== draggedItemType) {\n        return false;\n      }\n\n      return source.isDragging(this, sourceId);\n    }\n  }, {\n    key: \"isOverTarget\",\n    value: function isOverTarget(targetId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shallow: false\n      };\n\n      // undefined on initial render\n      if (!targetId) {\n        return false;\n      }\n\n      var shallow = options.shallow;\n\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      var targetType = this.registry.getTargetType(targetId);\n      var draggedItemType = this.getItemType();\n\n      if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n        return false;\n      }\n\n      var targetIds = this.getTargetIds();\n\n      if (!targetIds.length) {\n        return false;\n      }\n\n      var index = targetIds.indexOf(targetId);\n\n      if (shallow) {\n        return index === targetIds.length - 1;\n      } else {\n        return index > -1;\n      }\n    }\n  }, {\n    key: \"getItemType\",\n    value: function getItemType() {\n      return this.store.getState().dragOperation.itemType;\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem() {\n      return this.store.getState().dragOperation.item;\n    }\n  }, {\n    key: \"getSourceId\",\n    value: function getSourceId() {\n      return this.store.getState().dragOperation.sourceId;\n    }\n  }, {\n    key: \"getTargetIds\",\n    value: function getTargetIds() {\n      return this.store.getState().dragOperation.targetIds;\n    }\n  }, {\n    key: \"getDropResult\",\n    value: function getDropResult() {\n      return this.store.getState().dragOperation.dropResult;\n    }\n  }, {\n    key: \"didDrop\",\n    value: function didDrop() {\n      return this.store.getState().dragOperation.didDrop;\n    }\n  }, {\n    key: \"isSourcePublic\",\n    value: function isSourcePublic() {\n      return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n  }, {\n    key: \"getInitialClientOffset\",\n    value: function getInitialClientOffset() {\n      return this.store.getState().dragOffset.initialClientOffset;\n    }\n  }, {\n    key: \"getInitialSourceClientOffset\",\n    value: function getInitialSourceClientOffset() {\n      return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n  }, {\n    key: \"getClientOffset\",\n    value: function getClientOffset() {\n      return this.store.getState().dragOffset.clientOffset;\n    }\n  }, {\n    key: \"getSourceClientOffset\",\n    value: function getSourceClientOffset() {\n      return _getSourceClientOffset(this.store.getState().dragOffset);\n    }\n  }, {\n    key: \"getDifferenceFromInitialOffset\",\n    value: function getDifferenceFromInitialOffset() {\n      return _getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n  }]);\n\n  return DragDropMonitorImpl;\n}();","map":{"version":3,"mappings":"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","names":["invariant","getDifferenceFromInitialOffset","getSourceClientOffset","areDirty","matchesType","DragDropMonitorImpl","store","registry","subscribeToStateChange","listener","options","handlerIds","Array","isArray","prevStateId","getState","stateId","handleChange","state","currentStateId","canSkipListener","dirtyHandlerIds","subscribe","subscribeToOffsetChange","previousState","dragOffset","nextState","sourceId","canDragSource","source","getSource","isDragging","canDrag","targetId","canDropOnTarget","target","getTarget","didDrop","targetType","getTargetType","draggedItemType","getItemType","canDrop","Boolean","isDraggingSource","isSourcePublic","sourceType","getSourceType","isOverTarget","shallow","targetIds","getTargetIds","length","index","indexOf","dragOperation","itemType","getItem","item","getSourceId","getDropResult","dropResult","getInitialClientOffset","initialClientOffset","getInitialSourceClientOffset","initialSourceClientOffset","getClientOffset","clientOffset"],"sources":["/Users/johannadeweerdt/Documents/school/erasmus/code/lydoplevelse/node_modules/dnd-core/src/classes/DragDropMonitorImpl.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type { Store } from 'redux'\n\nimport type {\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n\tListener,\n\tUnsubscribe,\n\tXYCoord,\n} from '../interfaces.js'\nimport type { State } from '../reducers/index.js'\nimport {\n\tgetDifferenceFromInitialOffset,\n\tgetSourceClientOffset,\n} from '../utils/coords.js'\nimport { areDirty } from '../utils/dirtiness.js'\nimport { matchesType } from '../utils/matchesType.js'\n\nexport class DragDropMonitorImpl implements DragDropMonitor {\n\tprivate store: Store<State>\n\tpublic readonly registry: HandlerRegistry\n\n\tpublic constructor(store: Store<State>, registry: HandlerRegistry) {\n\t\tthis.store = store\n\t\tthis.registry = registry\n\t}\n\n\tpublic subscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions: { handlerIds?: string[] } = {},\n\t): Unsubscribe {\n\t\tconst { handlerIds } = options\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\t\tinvariant(\n\t\t\ttypeof handlerIds === 'undefined' || Array.isArray(handlerIds),\n\t\t\t'handlerIds, when specified, must be an array of strings.',\n\t\t)\n\n\t\tlet prevStateId = this.store.getState().stateId\n\t\tconst handleChange = () => {\n\t\t\tconst state = this.store.getState()\n\t\t\tconst currentStateId = state.stateId\n\t\t\ttry {\n\t\t\t\tconst canSkipListener =\n\t\t\t\t\tcurrentStateId === prevStateId ||\n\t\t\t\t\t(currentStateId === prevStateId + 1 &&\n\t\t\t\t\t\t!areDirty(state.dirtyHandlerIds, handlerIds))\n\n\t\t\t\tif (!canSkipListener) {\n\t\t\t\t\tlistener()\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tprevStateId = currentStateId\n\t\t\t}\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic subscribeToOffsetChange(listener: Listener): Unsubscribe {\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\n\t\tlet previousState = this.store.getState().dragOffset\n\t\tconst handleChange = () => {\n\t\t\tconst nextState = this.store.getState().dragOffset\n\t\t\tif (nextState === previousState) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpreviousState = nextState\n\t\t\tlistener()\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic canDragSource(sourceId: string | undefined): boolean {\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.canDrag(this, sourceId)\n\t}\n\n\tpublic canDropOnTarget(targetId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\t\tconst target = this.registry.getTarget(targetId)\n\t\tinvariant(target, `Expected to find a valid target. targetId=${targetId}`)\n\n\t\tif (!this.isDragging() || this.didDrop()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\treturn (\n\t\t\tmatchesType(targetType, draggedItemType) && target.canDrop(this, targetId)\n\t\t)\n\t}\n\n\tpublic isDragging(): boolean {\n\t\treturn Boolean(this.getItemType())\n\t}\n\n\tpublic isDraggingSource(sourceId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId, true)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (!this.isDragging() || !this.isSourcePublic()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst sourceType = this.registry.getSourceType(sourceId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (sourceType !== draggedItemType) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.isDragging(this, sourceId)\n\t}\n\n\tpublic isOverTarget(\n\t\ttargetId: string | undefined,\n\t\toptions = { shallow: false },\n\t): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst { shallow } = options\n\t\tif (!this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (draggedItemType && !matchesType(targetType, draggedItemType)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetIds = this.getTargetIds()\n\t\tif (!targetIds.length) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst index = targetIds.indexOf(targetId)\n\t\tif (shallow) {\n\t\t\treturn index === targetIds.length - 1\n\t\t} else {\n\t\t\treturn index > -1\n\t\t}\n\t}\n\n\tpublic getItemType(): Identifier {\n\t\treturn this.store.getState().dragOperation.itemType as Identifier\n\t}\n\n\tpublic getItem(): any {\n\t\treturn this.store.getState().dragOperation.item\n\t}\n\n\tpublic getSourceId(): string | null {\n\t\treturn this.store.getState().dragOperation.sourceId\n\t}\n\n\tpublic getTargetIds(): string[] {\n\t\treturn this.store.getState().dragOperation.targetIds\n\t}\n\n\tpublic getDropResult(): any {\n\t\treturn this.store.getState().dragOperation.dropResult\n\t}\n\n\tpublic didDrop(): boolean {\n\t\treturn this.store.getState().dragOperation.didDrop\n\t}\n\n\tpublic isSourcePublic(): boolean {\n\t\treturn Boolean(this.store.getState().dragOperation.isSourcePublic)\n\t}\n\n\tpublic getInitialClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialClientOffset\n\t}\n\n\tpublic getInitialSourceClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialSourceClientOffset\n\t}\n\n\tpublic getClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.clientOffset\n\t}\n\n\tpublic getSourceClientOffset(): XYCoord | null {\n\t\treturn getSourceClientOffset(this.store.getState().dragOffset)\n\t}\n\n\tpublic getDifferenceFromInitialOffset(): XYCoord | null {\n\t\treturn getDifferenceFromInitialOffset(this.store.getState().dragOffset)\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}